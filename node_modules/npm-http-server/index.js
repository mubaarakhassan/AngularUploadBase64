'use strict';

exports.__esModule = true;
exports.createServer = exports.createRequestHandler = undefined;

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _osTmpdir = require('os-tmpdir');

var _osTmpdir2 = _interopRequireDefault(_osTmpdir);

var _path = require('path');

var _fs = require('fs');

var _semver = require('semver');

var _PackageUtils = require('./PackageUtils');

var _IndexUtils = require('./IndexUtils');

var _MetadataUtils = require('./MetadataUtils');

var _RegistryUtils = require('./RegistryUtils');

var _BowerUtils = require('./BowerUtils');

var _FileUtils = require('./FileUtils');

var _ResponseUtils = require('./ResponseUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OneMinute = 60;
var OneDay = OneMinute * 60 * 24;
var OneYear = OneDay * 365;

var checkLocalCache = function checkLocalCache(dir, callback) {
  return (0, _fs.stat)((0, _path.join)(dir, 'package.json'), function (error, stats) {
    callback(stats && stats.isFile());
  });
};

var ResolveExtensions = ['', '.js', '.json'];

var createTempPath = function createTempPath(name) {
  return (0, _path.join)((0, _osTmpdir2.default)(), 'npm-http-server-' + name);
};

/**
 * Resolves a path like "lib/file" into "lib/file.js" or
 * "lib/file.json" depending on which one is available, similar
 * to how require('lib/file') does.
 */
var resolveFile = function resolveFile(path, useIndex, callback) {
  ResolveExtensions.reduceRight(function (next, ext) {
    var file = path + ext;

    return function () {
      (0, _fs.stat)(file, function (error, stats) {
        if (error) {
          if (error.code === 'ENOENT') {
            next();
          } else {
            callback(error);
          }
        } else if (useIndex && stats.isDirectory()) {
          resolveFile((0, _path.join)(file, 'index'), false, function (error, indexFile, indexStats) {
            if (error) {
              callback(error);
            } else if (indexFile) {
              callback(null, indexFile, indexStats);
            } else {
              next();
            }
          });
        } else {
          callback(null, file, stats);
        }
      });
    };
  }, callback)();
};

/**
 * Creates and returns a function that can be used in the "request"
 * event of a standard node HTTP server. Options are:
 *
 * - registryURL    The URL of the npm registry (defaults to https://registry.npmjs.org)
 * - bowerBundle    A special pathname that is used to create and serve zip files required by Bower
 *                  (defaults to "/bower.zip")
 * - redirectTTL    The TTL (in seconds) for redirects (defaults to 0)
 * - autoIndex      Automatically generate index HTML pages for directories (defaults to true)
 *
 * Supported URL schemes are:
 *
 * /history@1.12.5/umd/History.min.js (recommended)
 * /history@1.12.5 (package.json's main is implied)
 *
 * Additionally, the following URLs are supported but will return a
 * temporary (302) redirect:
 *
 * /history (redirects to version, latest is implied)
 * /history/umd/History.min.js (redirects to version, latest is implied)
 * /history@latest/umd/History.min.js (redirects to version)
 * /history@^1/umd/History.min.js (redirects to max satisfying version)
 */
var createRequestHandler = exports.createRequestHandler = function createRequestHandler() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var registryURL = options.registryURL || 'https://registry.npmjs.org';
  var bowerBundle = options.bowerBundle || '/bower.zip';
  var redirectTTL = options.redirectTTL || 0;
  var autoIndex = options.autoIndex !== false;
  var maximumDepth = options.maximumDepth || Number.MAX_VALUE;
  var blacklist = options.blacklist || [];

  var handleRequest = function handleRequest(req, res) {
    var url = (0, _PackageUtils.parsePackageURL)(req.url);

    if (url == null) return (0, _ResponseUtils.sendInvalidURLError)(res, req.url);

    var pathname = url.pathname,
        search = url.search,
        query = url.query,
        packageName = url.packageName,
        version = url.version,
        filename = url.filename;

    var displayName = packageName + '@' + version;

    var isBlacklisted = blacklist.indexOf(packageName) !== -1;

    if (isBlacklisted) return (0, _ResponseUtils.sendText)(res, 403, 'Package ' + packageName + ' is blacklisted');

    // Step 1: Fetch the package from the registry and store a local copy.
    // Redirect if the URL does not specify an exact version number.
    var fetchPackage = function fetchPackage(next) {
      var packageDir = createTempPath(displayName);

      checkLocalCache(packageDir, function (isCached) {
        if (isCached) return next(packageDir); // Best case: we already have this package on disk.

        // Fetch package info from NPM registry.
        (0, _RegistryUtils.getPackageInfo)(registryURL, packageName, function (error, packageInfo) {
          if (error) return (0, _ResponseUtils.sendServerError)(res, error);

          if (packageInfo == null) return (0, _ResponseUtils.sendNotFoundError)(res, 'package "' + packageName + '"');

          if (packageInfo.versions == null) return (0, _ResponseUtils.sendServerError)(res, new Error('Unable to retrieve info for package ' + packageName));

          var versions = packageInfo.versions,
              tags = packageInfo['dist-tags'];


          if (version in versions) {
            // A valid request for a package we haven't downloaded yet.
            var packageConfig = versions[version];
            var tarballURL = packageConfig.dist.tarball;

            (0, _PackageUtils.getPackage)(tarballURL, packageDir, function (error) {
              if (error) {
                (0, _ResponseUtils.sendServerError)(res, error);
              } else {
                next(packageDir);
              }
            });
          } else if (version in tags) {
            (0, _ResponseUtils.sendRedirect)(res, (0, _PackageUtils.createPackageURL)(packageName, tags[version], filename, search), redirectTTL);
          } else {
            var maxVersion = (0, _semver.maxSatisfying)(Object.keys(versions), version);

            if (maxVersion) {
              (0, _ResponseUtils.sendRedirect)(res, (0, _PackageUtils.createPackageURL)(packageName, maxVersion, filename, search), redirectTTL);
            } else {
              (0, _ResponseUtils.sendNotFoundError)(res, 'package ' + displayName);
            }
          }
        });
      });
    };

    // Step 2: Determine which file we're going to serve and get its stats.
    // Redirect if the request targets a directory with no trailing slash.
    var findFile = function findFile(packageDir, next) {
      if (filename === bowerBundle) {
        (0, _BowerUtils.createBowerPackage)(packageDir, function (error, file) {
          if (error) {
            (0, _ResponseUtils.sendServerError)(res, error);
          } else if (file == null) {
            (0, _ResponseUtils.sendNotFoundError)(res, 'bower.zip in package ' + displayName);
          } else {
            next('bower.zip', null);
          }
        });
      } else if (filename) {
        var path = (0, _path.join)(packageDir, filename);

        // Based on the URL, figure out which file they want.
        resolveFile(path, false, function (error, file, stats) {
          if (error) {
            (0, _ResponseUtils.sendServerError)(res, error);
          } else if (file == null) {
            (0, _ResponseUtils.sendNotFoundError)(res, 'file "' + filename + '" in package ' + displayName);
          } else if (stats.isDirectory() && pathname[pathname.length - 1] !== '/') {
            // Append `/` to directory URLs
            (0, _ResponseUtils.sendRedirect)(res, pathname + '/' + search, OneYear);
          } else {
            next(file.replace(packageDir, ''), stats);
          }
        });
      } else {
        // No filename in the URL. Try to serve the package's "main" file.
        (0, _fs.readFile)((0, _path.join)(packageDir, 'package.json'), 'utf8', function (error, data) {
          if (error) return (0, _ResponseUtils.sendServerError)(res, error);

          var packageConfig = void 0;
          try {
            packageConfig = JSON.parse(data);
          } catch (error) {
            return (0, _ResponseUtils.sendText)(res, 500, 'Error parsing ' + displayName + '/package.json: ' + error.message);
          }

          var mainFilename = void 0;
          var queryMain = query && query.main;

          if (queryMain) {
            if (!(queryMain in packageConfig)) return (0, _ResponseUtils.sendNotFoundError)(res, 'field "' + queryMain + '" in ' + displayName + '/package.json');

            mainFilename = packageConfig[queryMain];
          } else {
            if (typeof packageConfig.unpkg === 'string') {
              // The "unpkg" field allows packages to explicitly declare the
              // file to serve at the bare URL (see #59).
              mainFilename = packageConfig.unpkg;
            } else if (typeof packageConfig.browser === 'string') {
              // Fall back to the "browser" field if declared (only support strings).
              mainFilename = packageConfig.browser;
            } else {
              // If there is no main, use "index" (same as npm).
              mainFilename = packageConfig.main || 'index';
            }
          }

          resolveFile((0, _path.join)(packageDir, mainFilename), true, function (error, file, stats) {
            if (error) {
              (0, _ResponseUtils.sendServerError)(res, error);
            } else if (file == null) {
              (0, _ResponseUtils.sendNotFoundError)(res, 'main file "' + mainFilename + '" in package ' + displayName);
            } else {
              next(file.replace(packageDir, ''), stats);
            }
          });
        });
      }
    };

    // Step 3: Send the file, JSON metadata, or HTML directory listing.
    var serveFile = function serveFile(baseDir, path, stats) {
      if (query.json != null) {
        (0, _MetadataUtils.generateMetadata)(baseDir, path, stats, maximumDepth, function (error, metadata) {
          if (metadata) {
            (0, _ResponseUtils.sendJSON)(res, metadata, OneYear);
          } else {
            (0, _ResponseUtils.sendServerError)(res, 'unable to generate JSON metadata for ' + displayName + filename);
          }
        });
        // TODO: Remove "stats == null" check when we remove Bower support.
      } else if (stats == null || stats.isFile()) {
        (0, _ResponseUtils.sendFile)(res, (0, _path.join)(baseDir, path), stats, OneYear);
      } else if (autoIndex && stats.isDirectory()) {
        (0, _RegistryUtils.getPackageInfo)(registryURL, packageName, function (error, packageInfo) {
          if (error) {
            (0, _ResponseUtils.sendServerError)(res, 'unable to generate index page for ' + displayName + filename);
          } else {
            (0, _IndexUtils.generateDirectoryIndexHTML)(packageInfo, version, baseDir, path, function (error, html) {
              if (html) {
                (0, _ResponseUtils.sendHTML)(res, html, OneYear);
              } else {
                (0, _ResponseUtils.sendServerError)(res, 'unable to generate index page for ' + displayName + filename);
              }
            });
          }
        });
      } else {
        (0, _ResponseUtils.sendInvalidURLError)(res, '' + displayName + filename + ' is a ' + (0, _FileUtils.getFileType)(stats));
      }
    };

    fetchPackage(function (packageDir) {
      findFile(packageDir, function (file, stats) {
        serveFile(packageDir, file, stats);
      });
    });
  };

  return handleRequest;
};

/**
 * Creates and returns an HTTP server that serves files from NPM packages.
 */
var createServer = exports.createServer = function createServer(options) {
  return _http2.default.createServer(createRequestHandler(options));
};